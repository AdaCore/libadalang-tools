-- C85013A.ADA

--                             Grant of Unlimited Rights
--
--     Under contracts F33600-87-D-0337, F33600-84-D-0280, MDA903-79-C-0687,
--     F08630-91-C-0015, and DCA100-97-D-0025, the U.S. Government obtained
--     unlimited rights in the software and documentation contained herein.
--     Unlimited rights are defined in DFAR 252.227-7013(a)(19).  By making
--     this public release, the Government intends to confer upon all
--     recipients unlimited rights  equal to those held by the Government.
--     These rights include rights to use, duplicate, release or disclose the
--     released technical data and computer software in whole or in part, in
--     any manner and for any purpose whatsoever, and to have or permit others
--     to do so.
--
--                                    DISCLAIMER
--
--     ALL MATERIALS OR INFORMATION HEREIN RELEASED, MADE AVAILABLE OR
--     DISCLOSED ARE AS IS.  THE GOVERNMENT MAKES NO EXPRESS OR IMPLIED
--     WARRANTY AS TO ANY MATTER WHATSOEVER, INCLUDING THE CONDITIONS OF THE
--     SOFTWARE, DOCUMENTATION OR OTHER INFORMATION RELEASED, MADE AVAILABLE
--     OR DISCLOSED, OR THE OWNERSHIP, MERCHANTABILITY, OR FITNESS FOR A
--     PARTICULAR PURPOSE OF SAID MATERIAL.
--*
-- CHECK THAT:

--   A) A SUBPROGRAM OR ENTRY CAN BE RENAMED WITH:
--        A1) DIFFERENT PARAMETER NAMES;
--        A2) DIFFERENT DEFAULT VALUES;
--        A3) DIFFERENT PARAMETERS HAVING DEFAULT VALUES;
--      AND THAT THE NEW NAMES/DEFAULTS ARE USED WHEN THE NEW NAME
--      IS USED IN A CALL.

--   B) FORMAL PARAMETER CONSTRAINTS FOR THE NEW NAME ARE IGNORED IN
--      FAVOR OF THE CONSTRAINTS ASSOCIATED WITH THE RENAMED ENTITY.

-- EG  02/22/84

with Report;

procedure C85013a is

   use Report;

begin

   Test
     ("C85013A",
      "CHECK THAT A SUBPROGRAM CAN BE RENAMED AND " &
      "THAT THE NEW NAMES/DEFAULTS ARE USED WITH " &
      "THE CONSTRAINTS ASSOCIATED WITH THE RENAMED" &
      " ENTITY");

   declare

      type Ta is array (1 .. 5) of Integer;

      function Proc1
        (A : Integer := 1;
         B : Ta      := (1 .. 5 => 1)) return Integer;
      function Proca
        (C : Integer := 1;
         D : Ta      := (1 .. 5 => 1)) return Integer renames
        Proc1;
      function Procb
        (B : Integer := 1;
         A : Ta      := (1 .. 5 => 1)) return Integer renames
        Proc1;
      function Procc
        (A : Integer := 2;
         B : Ta      := (1, 2, 3, 4, 5)) return Integer renames
        Proc1;
      function Procd
        (C : Integer := 2;
         D : Ta      := (1, 2, 3, 4, 5)) return Integer renames
        Proc1;

      function Proc1 (A : Integer := 1; B : Ta := (1 .. 5 => 1)) return Integer
      is
      begin
         for I in 1 .. 5 loop
            if A = B (I) then
               return I;
            end if;
         end loop;
         return 0;
      end Proc1;

   begin

      if Proc1 /= 1 then
         Failed ("CASE A : PARAMETERS NOT PROPERLY INITIALIZED");
      end if;
      if Proc1 (A => 2) /= 0 then
         Failed ("CASE A : INCORRECT RESULT");
      end if;
      if Proca /= 1 then
         Failed ("CASE A1 : INCORRECT RESULT (DEFAULT)");
      end if;
      if Proca (D => (5, 4, 3, 2, 1)) /= 5 then
         Failed ("CASE A1 : INCORRECT RESULT");
      end if;
      if Procb /= 1 then
         Failed ("CASE A1 : INCORRECT RESULT (DEFAULT)");
      end if;
      if Procb (A => (5, 4, 3, 2, 1), B => 2) /= 4 then
         Failed ("CASE A1 : INCORRECT RESULT ");
      end if;
      if Procc /= 2 then
         Failed ("CASE A2 : INCORRECT RESULT (DEFAULT)");
      end if;
      if Procc (3) /= 3 then
         Failed ("CASE A2 : INCORRECT RESULT ");
      end if;
      if Procd /= 2 then
         Failed ("CASE A2 : INCORRECT RESULT (DEFAULT)");
      end if;
      if Procd (4) /= 4 then
         Failed ("CASE A2 : INCORRECT RESULT ");
      end if;

   end;

   declare

      type Ta is array (Integer range <>) of Integer;
      subtype Sta1 is Ta (1 .. 5);
      subtype Sta2 is Ta (11 .. 15);

      procedure Proc1 (A : Sta1; Id : String);
      procedure Proc2 (A : Sta2; Id : String) renames Proc1;

      procedure Proc1 (A : Sta1; Id : String) is
      begin
         if A'First /= Ident_Int (1) then
            Failed ("CASE B : INCORRECT LOWER BOUND " & "GENERATED BY " & Id);
         end if;
         if A'Last /= Ident_Int (5) then
            Failed ("CASE B : INCORRECT UPPER BOUND " & "GENERATED BY " & Id);
         end if;
      end Proc1;

   begin

      Proc1 ((1, 2, 3, 4, 5), "PROC1");
      Proc2 ((6, 7, 8, 9, 10), "PROC2");

   end;

   Result;

end C85013a;
