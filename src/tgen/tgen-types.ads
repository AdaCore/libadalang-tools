------------------------------------------------------------------------------
--                                                                          --
--                                  TGen                                    --
--                                                                          --
--                       Copyright (C) 2022, AdaCore                        --
--                                                                          --
-- TGen  is  free software; you can redistribute it and/or modify it  under --
-- under  terms of  the  GNU General  Public License  as  published by  the --
-- Free  Software  Foundation;  either version 3, or  (at your option)  any --
-- later version. This software  is distributed in the hope that it will be --
-- useful but  WITHOUT  ANY  WARRANTY; without even the implied warranty of --
-- MERCHANTABILITY  or  FITNESS  FOR A PARTICULAR PURPOSE.                  --
--                                                                          --
-- As a special  exception  under  Section 7  of  GPL  version 3,  you are  --
-- granted additional  permissions described in the  GCC  Runtime  Library  --
-- Exception, version 3.1, as published by the Free Software Foundation.    --
--                                                                          --
-- You should have received a copy of the GNU General Public License and a  --
-- copy of the GCC Runtime Library Exception along with this program;  see  --
-- the files COPYING3 and COPYING.RUNTIME respectively.  If not, see        --
-- <http://www.gnu.org/licenses/>.                                          --
------------------------------------------------------------------------------

with Libadalang.Analysis;
with Langkit_Support.Text;

with Ada.Containers;
with Ada.Containers.Indefinite_Hashed_Maps;
with Ada.Containers.Hashed_Maps;
with Ada.Containers.Ordered_Sets;
with Ada.Numerics.Big_Numbers.Big_Integers;
with Ada.Strings.Unbounded;           use Ada.Strings.Unbounded;
with Ada.Strings.Wide_Wide_Hash;
with Ada.Strings.Wide_Wide_Unbounded; use Ada.Strings.Wide_Wide_Unbounded;
with Ada.Unchecked_Deallocation;

with GNATCOLL.JSON;     use GNATCOLL.JSON;
with GNATCOLL.Refcount; use GNATCOLL.Refcount;

limited with TGen.Context;
limited with TGen.Strategies;
with TGen.Subprograms; use TGen.Subprograms;
with TGen.Numerics;    use TGen.Numerics;
limited with Tgen.Types.Array_Types;
limited with Tgen.Types.Enum_Types;
limited with Tgen.Types.Int_Types;
limited with TGen.Types.Real_Types;
limited with Tgen.Types.Record_Types;
with TGen.Strings; use TGen.Strings;

package TGen.Types is

   package LAL renames Libadalang.Analysis;

   use type Ada_Qualified_Name;
   use type Ada.Containers.Count_Type;

   type Typ is tagged record
      Name : Ada_Qualified_Name;
      --  Fully qualified name of the type

   end record;

   type Typ_Kind is (Invalid_Kind,
                     Signed_Int_Kind,
                     Mod_Int_Kind,
                     Bool_Kind,
                     Char_Kind,
                     Enum_Kind,
                     Float_Kind,
                     Fixed_Kind,
                     Decimal_Kind,
                     Ptr_Kind,
                     Unconstrained_Array_Kind,
                     Constrained_Array_Kind,
                     Disc_Record_Kind,
                     Non_Disc_Record_Kind,
                     Anonymous_Kind,
                     Unsupported);

   subtype Discrete_Typ_Range is Typ_Kind range Signed_Int_Kind .. Enum_Kind;

   subtype Real_Typ_Range is Typ_Kind range Float_Kind .. Fixed_Kind;

   subtype Array_Typ_Range is
     Typ_Kind range Unconstrained_Array_Kind .. Constrained_Array_Kind;

   subtype Record_Typ_Range
     is Typ_Kind range Disc_Record_Kind .. Non_Disc_Record_Kind;

   subtype Big_Integer is Big_Int.Big_Integer;

   function Image (Self : Typ) return String;

   function Is_Anonymous (Self : Typ) return Boolean;

   function Fully_Qualified_Name (Self : Typ) return String is
     (To_Ada (Self.Name));

   function Parent_Package_Name (Self : Typ) return String is
     (raise Program_Error with "To implement");

   function Type_Name (Self : Typ) return String is
     (if Ada_Identifier_Vectors.Is_Empty (Self.Name)
      then +Langkit_Support.Text.To_Text ("anonymous")
      else +Unbounded_String (Self.Name.Last_Element));

   function Gen_Random_Function_Name
     (Self : Typ) return String is
     ("Gen_" & To_Ada (Self.Name));

   function Generation_Package_For_Type
     (Self : Typ'Class) return Unbounded_Text_Type;

   function Random_Strategy_Function
     (Self : Typ) return Subprogram_Data;
   --  Returns the spec of the random strategy function for the given type
   --  (that will be generated by default).

   function "<" (L : Typ'Class; R : Typ'Class) return Boolean is
     (To_Ada (L.Name) < To_Ada (R.Name));

   function Slug (Self : Typ) return String;
   --  Return a unique identifier for the type

   function Package_Name (Self : Typ) return String;
   --  Return the package name this type belongs to

   function Is_Constrained (Self : Typ) return Boolean is (False);
   --  An array type with indefinite bounds must be constrained, a discriminant
   --  record type must be constrained.

   function Generate_Random_Strategy
     (Self    : Typ;
      Context : in out TGen.Context.Generation_Context)
      return TGen.Strategies.Strategy_Type'Class;

   function Generate_Constrained_Random_Strategy
     (Self    : Typ;
      Context : TGen.Context.Generation_Context)
      return TGen.Strategies.Strategy_Type'Class
     with Pre => Self.Is_Constrained;

   function Generate_Static
     (Self    : Typ;
      Context : in out TGen.Context.Generation_Context)
      return TGen.Strategies.Static_Strategy_Type'Class;
   --  Return a strategy generating elements of the given type

   function Type_Image (Self : Typ) return String is ("");

   function Kind (Self : Typ) return Typ_Kind;

   procedure Free_Content (Self : in out Typ) is null;

   type Scalar_Typ (Is_Static : Boolean) is new Typ with null record;

   type Access_Typ is new Typ with null record;

   function Image (Self : Access_Typ) return String;

   type Composite_Typ is new Typ with null record;

   procedure Free_Content_Wide (Self : in out Typ'Class);

   package SP is new Shared_Pointers
     (Element_Type => Typ'Class, Release => Free_Content_Wide);

   function "<" (L : Defining_Name; R : Defining_Name) return Boolean is
     (Image (L.P_Fully_Qualified_Name) < Image (R.P_Fully_Qualified_Name));

   function "<" (L, R : SP.Ref) return Boolean is
     (To_Ada (L.Get.Name)
      < To_Ada (R.Get.Name));

   function "=" (L, R : SP.Ref) return Boolean is
     ((L.Is_Null and then R.Is_Null)
       or else ((not L.Is_Null)
                and then (not R.Is_Null)
                and then L.Get.Name = R.Get.Name));

   --  As_<Target>_Typ functions are useful to view a certain objetc of type
   --  Typ'Class wrapped in a smart pointer as a <Target>_Typ, and thus be able
   --  to access the components and primitives defined for that particular
   --  type. The return value is the object encapsulated in the smart pointer,
   --  so under no circumstances should it be freed.

   Big_Zero : constant Big_Integer :=
     Ada.Numerics.Big_Numbers.Big_Integers.To_Big_Integer (0);

   type Unsupported_Typ is new Typ with null record;

   function Kind (Self : Unsupported_Typ) return Typ_Kind is (Unsupported);

end TGen.Types;
